[{"path":"https://richfitz.github.io/thor/articles/thor.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"thor","text":"thor provides wrapper around LMDB; lightning memory-mapped database. embedded key-value store; server (like SQLite) - database exists purely disk uses file locking manage concurrent access processes. Key-value stores simple systems persistently storing values keys. case thor, keys data can strings (raw) data. provides low-level building block applications can built. complications come trying efficiently query store, patterns like “add new value previous value foo”. package provide faithful 1:1 mapping underlying LMDB C API requires much care R level crash R! Instead, probably cost performance, thor provides set wrappers try prevent crashes invalidating objects correct order. approach taken similar python interface LMDB; py-lmdb. whole point interacting database side effects, thor uses R6 interface. unfortunate effect complicating documentation somewhat R’s documentation focussed heavily functions package provides one function (thor::mdb_env) everything else happening methods object, objects creates. thor tries expose underlying LMDB interface nested set objects increasing power (complexity). objects package provides mdb_env: environment object, interface database file. Everything starts ! mdb_dbi: database handle. Multiple databases may stored within single environment one used object passed control database things affect. mdb_txn: transaction object. LMDB transactional database object used carry actions within transaction (getting putting data). mdb_cursor: cursor. go beyond basic get/put, cursors required. can used iterate ## *database, find entries. mdb_proxy: proxy result. used defer copying data database R long possible. ’s bit experiment ’ll see useful turns . objects help pages, even though mdb_env actual function. help pages every public function described (set printed displaying objects). functions can reached using $ - functions beginning . considered private; using can crash R. functions (format) exist way thor uses R6. basic operations, one can just use mdb_env object ignore rest package. interesting things, ’ll need transactions (mdb_txn), perhaps ’ll need cursors (mdb_cursor). proxy objects available use transactions.","code":""},{"path":"https://richfitz.github.io/thor/articles/thor.html","id":"the-environment","dir":"Articles","previous_headings":"","what":"The environment","title":"thor","text":"first step create “environment”; holds one “databases” (though simple case can forget detail just treat environment database). first argument thor::mdb_env filename - directory database files kept. using temporary file database. R6 object, database environment number methods can used perform actions database. print method groups theme: last group Helpers wrappers let ignore transactional nature LMDB just want really simple things. database currently empty: can add data : Now 10 keys database, holding value: LMDB stores keys sorted order (necessarily R’s sorted order - can see LMDB sorts things cmp method transaction - see ?mdb_txn), list return things order. key value (case just hex string) Delete key now 9 keys Test existence key exists mget method get multiple keys , mset set multiple key/value pairs mdel delete multiple keys . anything complicated want use transactions (see ). Informational methods return information state LMDB environment; path data stored contain two files - actual data lock file (see lmdb’s documentation ). Flags environment opened (corresponds arguments thor::mdb_env function) couple different forms (somewhat cryptic) information state environment (Note entries env$stat() number keys database)","code":"env <- thor::mdb_env(tempfile()) env ## <mdb_env> ##   Informational: ##     path() ##     flags() ##     info() ##     stat() ##     maxkeysize() ##     maxreaders() ##   Transactions: ##     begin(db = NULL, write = FALSE, sync = NULL, metasync =  ... ##     with_transaction(fun, db = NULL, write = FALSE) ##   Databases: ##     open_database(key = NULL, reversekey = FALSE, create = TRUE) ##     drop_database(db, delete = TRUE) ##   Management: ##     sync(force = FALSE) ##     copy(path, compact = FALSE) ##     close() ##     destroy() ##     reader_list() ##     reader_check() ##   Helpers: ##     get(key, missing_is_error = TRUE, as_raw = NULL, db = NULL) ##     put(key, value, overwrite = TRUE, append = FALSE, db = NULL) ##     del(key, db = NULL) ##     exists(key, db = NULL) ##     list(starts_with = NULL, as_raw = FALSE, size = NULL, db ... ##     mget(key, as_raw = NULL, db = NULL) ##     mput(key, value, overwrite = TRUE, append = FALSE, db =  ... ##     mdel(key, db = NULL) env$list() ## character(0) for (i in 1:10) {   env$put(ids::adjective_animal(),           ids::random_id()) } keys <- env$list() keys ##  [1] \"careful_gaur\"                    \"necessary_hen\"                   ##  [3] \"preagricultural_icterinewarbler\" \"rhombohedral_walrus\"             ##  [5] \"uninspirable_muntjac\"            \"unterrestrial_oryx\"              ##  [7] \"upstanding_vixen\"                \"waiting_xiaosaurus\"              ##  [9] \"wet_pullet\"                      \"zealous_illadopsis\" env$get(keys[[1]]) ## [1] \"101962d3792acd3b2ba11e94ce702e7c\" env$del(keys[[1]]) ## [1] TRUE length(env$list()) ## [1] 9 env$exists(keys[[1]]) ## [1] FALSE env$exists(keys[[2]]) ## [1] TRUE env$mdel(keys) ##  [1] FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE env$path() ## [1] \"/tmp/RtmpFhtUfe/file1e2910ba94e\" dir(env$path()) ## [1] \"data.mdb\" \"lock.mdb\" env$flags() ##   subdir readonly writemap metasync     sync mapasync     lock  rdahead  ##     TRUE    FALSE    FALSE     TRUE     TRUE    FALSE     TRUE     TRUE  ##  meminit  ##     TRUE env$info() ##    mapsize  last_pgno last_txnid maxreaders numreaders  ##    1048576          7         12        126          1 env$stat() ##          psize          depth   branch_pages     leaf_pages overflow_pages  ##           4096              0              0              0              0  ##        entries  ##              0"},{"path":"https://richfitz.github.io/thor/articles/thor.html","id":"transactions","dir":"Articles","previous_headings":"","what":"Transactions","title":"thor","text":"LMDB transactional; everything happens database, read write, happens transaction. write transaction either whole transaction happens none happens. read write transactions, “view” database consistent beginning end transaction. read transaction things write transaction writes database, read transaction “see” changes. can one write transaction , many read transactions ’d like. mdb_env, transaction object prints methods grouped theme","code":"txn <- env$begin(write = TRUE) txn ## <mdb_txn> ##   Informational: ##     id() ##     stat() ##   Finish: ##     commit() ##     abort(cache = TRUE) ##   Cursors: ##     cursor() ##   Data: ##     get(key, missing_is_error = TRUE, as_proxy = FALSE, as_r ... ##     put(key, value, overwrite = TRUE, append = FALSE) ##     del(key) ##     exists(key) ##     list(starts_with = NULL, as_raw = FALSE, size = NULL) ##     mget(key, as_proxy = FALSE, as_raw = NULL) ##     mput(key, value, overwrite = TRUE, append = FALSE) ##     mdel(key) ##     replace(key, value, as_raw = NULL) ##     pop(key, as_raw = NULL) ##   Compare: ##     cmp(a, b)"},{"path":"https://richfitz.github.io/thor/articles/thor.html","id":"simple-operations-put-get-del-etc","dir":"Articles","previous_headings":"Transactions","what":"Simple operations (put, get, del, etc)","title":"thor","text":"insert data database, use put method …get back , use get method …delete , use del method, returns TRUE object deleted FALSE test key exists , use exists method (uses cursor internally - see ) helper functions mget, mput mdel functions get / put del multiple keys , efficiently looping R: list keys, use list fetch multiple values (as_raw explained ) delete multiple values exists always vectorised database transactional, can now either use txn$commit() save changes txn$abort() discard changes.","code":"txn$put(\"key\", \"value\") txn$get(\"key\") ## [1] \"value\" txn$del(\"key\") ## [1] TRUE txn$del(\"key\") ## [1] FALSE txn$exists(\"key\") ## [1] FALSE values <- ids::sentence(length(keys), style = \"sentence\") txn$mput(keys, values) txn$list() ##  [1] \"careful_gaur\"                    \"necessary_hen\"                   ##  [3] \"preagricultural_icterinewarbler\" \"rhombohedral_walrus\"             ##  [5] \"uninspirable_muntjac\"            \"unterrestrial_oryx\"              ##  [7] \"upstanding_vixen\"                \"waiting_xiaosaurus\"              ##  [9] \"wet_pullet\"                      \"zealous_illadopsis\" txn$mget(keys[1:3], as_raw = FALSE) ## [1] \"21 upbeat walruses assembling madly\"   ## [2] \"4 eager lizards spurting purposefully\" ## [3] \"7 unkempt weasels hobbling youthfully\" txn$mdel(keys[1:3]) ## [1] TRUE TRUE TRUE txn$exists(keys) ##  [1] FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE"},{"path":"https://richfitz.github.io/thor/articles/thor.html","id":"multiple-transactions-at-once","dir":"Articles","previous_headings":"Transactions","what":"Multiple transactions at once","title":"thor","text":"well able roll back transaction, function serve transaction gets consistent view database. point one write transaction running, ’s committed yet. start another transaction, see uncommitted “changes” transaction made: (equivalently, env$list()). design LMDB, multiple active write transactions (write transaction made another process LMDB database, wait transaction complete write transaction start - cause R unresponsive time) Let’s commit changes made: committed transaction reused: New transactions can now see changes importantly old ones can’t old transaction consistent view database - point starts point ends, read-transaction see data read-write transaction see changes made. (cleaning things little)","code":"txn_new <- env$begin() txn_new$list() ## character(0) env$put(\"key\", \"value\") ## Error in self$.check_write(): Write transaction is already active for this environment env$begin(write = TRUE) ## Error in self$.check_write(): Write transaction is already active for this environment txn$commit() txn$list() ## Error in mdb_cursor_open(self$.ptr, self$.db$.ptr): txn has been cleaned up; can't use! env$list() ## [1] \"rhombohedral_walrus\"  \"uninspirable_muntjac\" \"unterrestrial_oryx\"   ## [4] \"upstanding_vixen\"     \"waiting_xiaosaurus\"   \"wet_pullet\"           ## [7] \"zealous_illadopsis\" txn_new$list() ## character(0) txn_new$abort() env$mdel(keys) ##  [1] FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE"},{"path":"https://richfitz.github.io/thor/articles/thor.html","id":"non-string-data","dir":"Articles","previous_headings":"Transactions","what":"Non-string data","title":"thor","text":"thor (LMDB) can handle two types data; strings () raw vectors. Raw vectors can used serialise R objects using serialize, allows storing arbitrary data. approach taken redux among packages. strings can represented raw vectors reverse true; character strings may contain null byte resulting string may make sense. thor uses presence null byte heuristic needs test value raw . string “hello” can converted raw: set bytes 2a 00 ff : poses problems specifying predicting return types, explored . thor tries hard set return type predictably; boolean arguments function determine type rather contents data. First, one might want store raw data database. Suppose want store contents mtcars value. ’s string can’t First serialise raw: creates fairly long string bytes converting back R object easy unserialize fetching data, thor work raw data return raw vector: can now store retrieve arbitrary R objects database. Automatic type detection mixed blessing (like pitfalls sapply) thor provides mechanisms taming . two values raw vectors - one can converted string one can’t value return type determined value object value argument as_raw. example character as_raw NULL value can represented string, raw value represented string. Specifying as_raw = TRUE always return raw everything can represented raw. specifying as_raw = FALSE throw error value converted string. mget, ’s bit trickier need check every value come see ’s string character. rules : , as_raw = FALSE return character error possible, otherwise (as_raw = TRUE, as_raw = NULL) always return list. make programming value as_raw entirely predicts container type. Within container, rule contents get(). , default (as_raw = NULL) returns list auto-detected types element: get raw one values binary, can’t : pull strings ’s ok:","code":"charToRaw(\"hello\") ## [1] 68 65 6c 6c 6f rawToChar(as.raw(c(42, 0, 255))) ## Error in rawToChar(as.raw(c(42, 0, 255))): embedded nul in string: '*\\0\\xff' txn <- env$begin(write = TRUE) txn$put(\"mtcars\", mtcars) ## Error in mdb_put(self$.ptr, self$.db$.ptr, key, value, overwrite, append): Invalid data type for 'value'; expected string or raw mtcars_ser <- serialize(mtcars, NULL) str(mtcars_ser) ##  raw [1:3807] 58 0a 00 00 ... identical(unserialize(mtcars_ser), mtcars) ## [1] TRUE txn$put(\"mtcars\", mtcars_ser) txn$list() ## [1] \"mtcars\" class(txn$get(\"mtcars\")) ## [1] \"raw\" identical(unserialize(txn$get(\"mtcars\")), mtcars) ## [1] TRUE txn$del(\"mtcars\") ## [1] TRUE bytes <- as.raw(c(42, 0, 255)) string <- charToRaw(\"hello!\")  txn$put(\"bytes\", bytes) txn$put(\"string\", string) txn$get(\"string\") ## [1] \"hello!\" txn$get(\"bytes\") ## [1] 2a 00 ff txn$mget(c(\"string\", \"bytes\")) ## [[1]] ## [1] \"hello!\" ##  ## [[2]] ## [1] 2a 00 ff txn$mget(c(\"string\", \"bytes\"), as_raw = TRUE) ## [[1]] ## [1] 68 65 6c 6c 6f 21 ##  ## [[2]] ## [1] 2a 00 ff txn$mget(c(\"string\", \"bytes\"), as_raw = FALSE) ## Error in thor_mget(self$.ptr, self$.db$.ptr, key, as_proxy, as_raw): value contains embedded nul bytes; cannot return string txn$mget(c(\"string\", \"string\"), as_raw = FALSE) ## [1] \"hello!\" \"hello!\" txn$abort()"},{"path":"https://richfitz.github.io/thor/articles/thor.html","id":"caveats","dir":"Articles","previous_headings":"","what":"Caveats","title":"thor","text":"LMDB allow multiple process access database time, enforce one write transaction. However make work relies file locking. LMDB documentation covers issues around detail - issues apply thor, though ensured thor’s design (R single threaded really affect us). crashed processes may leave stale lockfiles may need removed reader_check() use LMDB database remote systems, even processes host, file locking memory map sync may unreliable. may disappointing, multiple hosts really need server based solution, file based one. avoid long-lived transactions, can cause database size grow quickly.","code":""},{"path":"https://richfitz.github.io/thor/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Rich FitzJohn. Author, maintainer. Howard Chu. Author, copyright holder. Symas Corporation. Copyright holder. Martin Hedenfalk. Author, copyright holder. OpenLDAP Foundation. Copyright holder.","code":""},{"path":"https://richfitz.github.io/thor/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"FitzJohn R, Chu H, Hedenfalk M (2025). thor: Interface 'LMDB'. R package version 1.2.0, https://github.com/richfitz/thor.","code":"@Manual{,   title = {thor: Interface to 'LMDB'},   author = {Rich FitzJohn and Howard Chu and Martin Hedenfalk},   year = {2025},   note = {R package version 1.2.0},   url = {https://github.com/richfitz/thor}, }"},{"path":"https://richfitz.github.io/thor/index.html","id":"thor","dir":"","previous_headings":"","what":"Interface to LMDB","title":"Interface to LMDB","text":"R interface LMDB. LMDB embedded transactional key-value store package provides R mappings . wraps entire LMDB interface, except support duplicated keys.","code":""},{"path":"https://richfitz.github.io/thor/index.html","id":"documentation","dir":"","previous_headings":"","what":"Documentation","title":"Interface to LMDB","text":"package comes vignette describes main features package LMDB - see version online. package also reference documentation methods. may useful refer LMDB documentation along side reference documentation details (hopefully much).","code":""},{"path":"https://richfitz.github.io/thor/index.html","id":"usage","dir":"","previous_headings":"","what":"Usage","title":"Interface to LMDB","text":"Everything starts creating environment (lives point file system), using methods environment object interact database LMDB transactional, thor exposes like : one write transaction active given point time. can unlimited number read transactions. cursor interface advanced features (see vignette). keys values can strings binary value, latter working well serialize. efficient use R, thor extends LMDB interface implement bulk reads, writes deletes (mget, mput mdel).","code":"env <- thor::mdb_env(tempfile()) env ## <mdb_env> ##   Informational: ##     path() ##     flags() ##     info() ##     stat() ##     maxkeysize() ##     maxreaders() ##   Transactions: ##     begin(db = NULL, write = FALSE, sync = NULL, metasync =  ... ##     with_transaction(fun, db = NULL, write = FALSE) ##   Databases: ##     open_database(key = NULL, reversekey = FALSE, create = TRUE) ##     drop_database(db, delete = TRUE) ##   Management: ##     sync(force = FALSE) ##     copy(path, compact = FALSE) ##     close() ##     destroy() ##     reader_list() ##     reader_check() ##   Helpers: ##     get(key, missing_is_error = TRUE, as_raw = NULL, db = NULL) ##     put(key, value, overwrite = TRUE, append = FALSE, db = NULL) ##     del(key, db = NULL) ##     exists(key, db = NULL) ##     list(starts_with = NULL, as_raw = FALSE, size = NULL, db ... ##     mget(key, as_raw = NULL, db = NULL) ##     mput(key, value, overwrite = TRUE, append = FALSE, db =  ... ##     mdel(key, db = NULL) env$put(\"hello\", \"world\") ## NULL env$exists(\"hello\") ## [1] TRUE env$get(\"hello\") # world ## [1] \"world\" env$del(\"hello\") ## [1] TRUE txn <- env$begin(write = TRUE) txn ## <mdb_txn> ##   Informational: ##     id() ##     stat() ##   Finish: ##     commit() ##     abort(cache = TRUE) ##   Cursors: ##     cursor() ##   Data: ##     get(key, missing_is_error = TRUE, as_proxy = FALSE, as_r ... ##     put(key, value, overwrite = TRUE, append = FALSE) ##     del(key) ##     exists(key) ##     list(starts_with = NULL, as_raw = FALSE, size = NULL) ##     mget(key, as_proxy = FALSE, as_raw = NULL) ##     mput(key, value, overwrite = TRUE, append = FALSE) ##     mdel(key) ##     replace(key, value, as_raw = NULL) ##     pop(key, as_raw = NULL) ##   Compare: ##     cmp(a, b) txn$put(\"key\", \"value\") env$get(\"key\", missing_is_error = FALSE) # NULL - not committed yet txn$commit() env$get(\"key\") # new transactions see the value"},{"path":"https://richfitz.github.io/thor/index.html","id":"performance","dir":"","previous_headings":"","what":"Performance","title":"Interface to LMDB","text":"lmdb extremely fast database, package may much less fast underlying library. order make interface safe use R, quite bit error checking, length time involved calling methods R6 objects orders magnitude slower performing action lmdb database (R6’s fault primarily caused cost S3 method lookup $ object class attribute). vectorised functions help (e.g., mget, mput), prefer practical speed concern.","code":""},{"path":"https://richfitz.github.io/thor/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Interface to LMDB","text":"Install CRAN want try development version github, can install ","code":"install.packages(\"thor\") devtools::install_github(\"richfitz/thor\", upgrade = FALSE)"},{"path":"https://richfitz.github.io/thor/index.html","id":"license","dir":"","previous_headings":"","what":"License","title":"Interface to LMDB","text":"MIT + file LICENSE © Rich FitzJohn. package contains included code lmdb “OpenLDAP Public License” - see inst/LICENSE.lmdb details","code":""},{"path":"https://richfitz.github.io/thor/reference/mdb_cursor.html","id":null,"dir":"Reference","previous_headings":"","what":"Use mdb transactions — mdb_cursor","title":"Use mdb transactions — mdb_cursor","text":"Cursors required advanced queries mdb database, basic set functions mdb_txn sufficient.","code":""},{"path":"https://richfitz.github.io/thor/reference/mdb_cursor.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Use mdb transactions — mdb_cursor","text":"Cursors must created within transaction (turn created environment).","code":""},{"path":"https://richfitz.github.io/thor/reference/mdb_cursor.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"Use mdb transactions — mdb_cursor","text":"close Close cursor Usage:   close() Value:   None, called side effects Note: lmdb.h mdb_cursor_close() put Store data using cursor Usage:   put(key, value, overwrite = TRUE, append = FALSE) Arguments: key:   key (string raw) value:   value (string raw) overwrite:   mdb_txn $put append:   mdb_txn $put Value:   Logical scalar, indicating data previously stored key Note: lmdb.h mdb_cursor_put() del Delete current key Usage:   del() Value:   Logical, indicating value deleted (TRUE cursor valid operation). Primarily called side effect deleting data.  deletion, call mdb_cursor_get MDB_GET_CURRENT re-validate cursor. Note: lmdb.h mdb_cursor_del() replace Replace key's current value new value, returning old value.  like get() followed put within transaction. Usage:   replace(key, value, as_raw = NULL) Arguments: key:   key replace value:   new value store as_raw:   Return value raw.  value NULL return string possible (.e., null bytes) raw vector otherwise.  as_raw = TRUE always return raw vector.  as_raw = FALSE always return string, throw error possible. pop Delete key's value, returning value just deleted.  like get followed del within transaction. Usage:   pop(key, as_raw = NULL) Arguments: key:   key delete as_raw:   Return value raw.  value NULL return string possible (.e., null bytes) raw vector otherwise.  as_raw = TRUE always return raw vector.  as_raw = FALSE always return string, throw error possible. Value:   Depending as_raw value stored, NULL, character string raw vector first Move cursor first item database Usage:   first() Value:   Invisibly, logical indicating cursor position valid, primarily called side effects last Move cursor last item database Usage:   last() Value:   Invisibly, logical indicating cursor position valid, primarily called side effects move_next Move cursor next item database.  called last item database, invalidate cursor position. Usage:   move_next() Value:   Invisibly, logical indicating cursor position valid, primarily called side effects move_prev Move cursor previous item database.  called first item database, invalidate cursor position. Usage:   move_prev() Value:   Invisibly, logical indicating cursor position valid, primarily called side effects move_to Move cursor item database key key. key exist, invalidate cursor position. Usage:   move_to(key) Arguments: key:   Key move (string raw) Value:   Invisibly, logical indicating cursor position valid, primarily called side effects seek Move cursor item database key equal greater key.  key exist key key greater key exists, invalidate cursor position. Usage:   seek(key) Arguments: key:   Key seek (string raw) Value:   Invisibly, logical indicating cursor position valid, primarily called side effects get Move key fetch value Usage:   get(key, as_proxy = FALSE, as_raw = NULL) Arguments: key:   key find (string raw) as_proxy:   Return mdb_proxy object? as_raw:   Return value raw.  value NULL return string possible (.e., null bytes) raw vector otherwise.  as_raw = TRUE always return raw vector.  as_raw = FALSE always return string, throw error possible. Value:   Depending as_raw value stored, NULL, character string raw vector is_valid Test cursor valid (.e., pointing data can retrieved).  Cursors start invalid placed (e.g., first, last) can invalidated moving beginning end database. Usage:   is_valid() key Return current key Usage:   key(as_proxy = FALSE, as_raw = NULL) Arguments: as_proxy:   Return mdb_proxy object? as_raw:   Return value raw.  value NULL return string possible (.e., null bytes) raw vector otherwise.  as_raw = TRUE always return raw vector.  as_raw = FALSE always return string, throw error possible. value Return current value Usage:   value(as_proxy = FALSE, as_raw = NULL) Arguments: as_proxy:   Return mdb_proxy object? as_raw:   Return value raw.  value NULL return string possible (.e., null bytes) raw vector otherwise.  as_raw = TRUE always return raw vector.  as_raw = FALSE always return string, throw error possible.","code":""},{"path":"https://richfitz.github.io/thor/reference/mdb_cursor.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Use mdb transactions — mdb_cursor","text":"","code":"# Start by creating a new environment, and within that a write # transaction, and from that a new cursor.  But first put a bunch # of data into the database env <- thor::mdb_env(tempfile()) env$mput(letters, LETTERS) #> NULL txn <- env$begin(write = TRUE) cur <- txn$cursor()  # Move the cursor to the first position cur$first()  # The key and value: cur$key() #> [1] \"a\" cur$value() #> [1] \"A\"  # Move to a different key: cur$move_to(\"g\") cur$value() #> [1] \"G\"  # Delete the current item cur$del() #> [1] TRUE cur$key() #> [1] \"h\"  # We can't move to 'g' any more as it's gone: (cur$move_to(\"g\")) #> [1] FALSE cur$key() # NULL #> NULL  # But we can *seek* 'g', which will move to 'h' (cur$seek(\"g\")) #> [1] TRUE cur$key() # \"h\" #> [1] \"h\"  # Get raw values out: cur$value(as_raw = TRUE) #> [1] 48  # Cleanup env$destroy()"},{"path":"https://richfitz.github.io/thor/reference/mdb_dbi.html","id":null,"dir":"Reference","previous_headings":"","what":"Use mdb transactions — mdb_dbi","title":"Use mdb transactions — mdb_dbi","text":"Database handles fairly opaque objects used indicate database within mdb_env operations happen .  object therefore got methods, purely informative.  commonly, mdb_dbi object passed mdb_env's $begin() method begin transaction particular database.","code":""},{"path":"https://richfitz.github.io/thor/reference/mdb_dbi.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"Use mdb transactions — mdb_dbi","text":"path Return absolute path LMDB store (disk) Usage:   path() Value:   string Note: lmdb.h mdb_env_get_path() flags Return flags used construction LMDB environment Usage:   flags() Value:   named logical vector.  Names correspond arguments constructor. Note: lmdb.h mdb_env_get_flags() info Brief information LMDB environment Usage:   info() Value:   integer vector elements mapsize, last_pgno, last_txnid, maxreaders numreaders. Note: lmdb.h mdb_env_info() stat Brief statistics LMDB environment. Usage:   stat() Value:   integer vector elements psize (size database page), depth (depth B-tree), brancb_pages (number internal non-leaf) pages), leaf_pages (number leaf pages), overflow_pages (number overflow pages) entries (number data items). Note: lmdb.h mdb_env_stat() maxkeysize maximum size key (value can bigger ) Usage:   maxkeysize() Value:   single integer Note: lmdb.h mdb_env_get_maxkeysize() maxreaders maximum number readers Usage:   maxreaders() Value:   single integer Note: lmdb.h mdb_env_get_maxreaders() begin Begin transaction Usage:   begin(db = NULL, write = FALSE, sync = NULL, metasync = NULL) Arguments: db:   database handle, returned open_database.  NULL (default) default database used. write:   Scalar logical, indicating write transaction.  can one write transaction per database (see mdb_txn details) - error try open one. sync:   Scalar logical, indicating data synchronised synchronised (flushed disk) writes; see main parameter list. metasync:   Scalar logical, indicating metadata synchronised (flushed disk) writes; see main parameter list. Details:   Transactions key objects interacting LMDB database (aside convenience interface ).  described detail mdb_txn. Value:   mdb_txn object Note: lmdb.h mdb_begin() with_transaction Evaluate code within transaction Usage:   with_transaction(fun, db = NULL, write = FALSE) Arguments: fun:   function one argument work transaction.  with_transaction pass transaction function.  easily explained example, see bottom help db:   database handle, returned open_database.  NULL (default) default database used. write:   Scalar logical, indicating write transaction.  can one write transaction per database (see mdb_txn details) - error try open one. Details:   exists simplify pattern one wants open transaction, evaluate code transaction anything goes wrong abort, otherwise commit.  useful read-write transactions, can used (default readonly transactions, like begin(). open_database Open named database, return one already opened. Usage:   open_database(key = NULL, reversekey = FALSE, create = TRUE) Arguments: key:   Name database; NULL returns default database (always open). reversekey:   Compare strings reverse order? See reversekey documentation create:   Create database exist already? Details:   LMDB environments can hold multiple databases, provided opened maxdbs greater one.  always \"default\" database - unnamed dropped. databases key (.e., name) can dropped. database objects passed methods, notably drop_database begin Note: lmdb.h mdb_open() drop_database Drop database Usage:   drop_database(db, delete = TRUE) Arguments: db:   database object, returned open_database delete:   Scalar logical, indicating database deleted .  FALSE, values deleted database (.e., emptied). TRUE actual database deleted . Value:   return value, called side effects Note: lmdb.h mdb_drop() sync Flush data buffers disk. Usage:   sync(force = FALSE) Arguments: force:   Scalar logical; force synchronous flush.  Otherwise environment constructed sync = FALSE flushes omitted, mapasync = TRUE asynchronous. Details:   Data always written disk transaction committed, operating system may keep buffered.  LMDB always flushes OS buffers upon commit well, unless environment opened sync = FALSE part metasync = FALSE.  call valid environment opened readonly = TRUE. Note: lmdb.h mdb_env_sync() copy Copy entire environment state new path.  can used make backup database. Usage:   copy(path, compact = FALSE) Arguments: path:   Scalar character; new path compact:   Scalar logical; perform compaction copying?  omits free pages sequentially renumbers pages output.  can take longer default produce smaller database Value:   Invisibly, new path (allowing use $copy(tempfile)) Note: lmdb.h mdb_env_copy() & mdb_env_copy2() close Close environment.  closes cursors transactions (active write transactions aborted). Usage:   close() Value:   return value, called side effects Note: lmdb.h mdb_env_close() destroy Totally destroy LMDB environment.  closes database removes files.  Use care! Usage:   destroy() Value:   return value, called side effects reader_list List information database readers Usage:   reader_list() Value:   character matrix columns pid (process ID), thread (pointer address), txnid (small integer) Note: lmdb.h mdb_reader_list() reader_check Check , remove, stale entries reader lock table. Usage:   reader_check() Value:   integer, number stale readers discarded.  However, function primarily called side effect. Note: lmdb.h mdb_reader_check() get Retrieve value database Usage:   get(key, missing_is_error = TRUE, as_raw = NULL, db = NULL) Arguments: key:   string (raw vector) - key get missing_is_error:   Logical, indicating missing value error (default ).  Alternatively, missing_is_error = FALSE, missing value return NULL.  value can NULL (values must nonzero length) NULL unambiguously missing. as_raw:   Either NULL, logical, indicate result type required.  as_raw = NULL, default, value returned string possible.  possible return raw vector.  as_raw = TRUE, get() always return raw vector, even possibly represent value string.  as_raw = FALSE, get return string, throw error possible.  discussed detail thor vignette (vignette(\"thor\")) db:   database handle passed create transaction (see $begin method). Details:   helper method establishes temporary read-transaction, calls corresponding method mdb_txn aborts transaction. Note: lmdb.h mdb_get() put Put values database.  systems, might called \"set\". Usage:   put(key, value, overwrite = TRUE, append = FALSE, db = NULL) Arguments: key:   name key (string raw vector) value:   value save (string raw vector) overwrite:   Logical - TRUE overwrite existing data; FALSE throw error append:   Logical - TRUE, append given key/value end database.  option allows fast bulk loading keys already known correct order.  load unsorted keys append = TRUE error thrown db:   database handle passed create transaction (see $begin method). Details:   helper method establishes temporary read-write transaction, calls corresponding method mdb_txn commits transaction.  possible use existing write transaction effect environment. Note: lmdb.h mdb_put() del Remove key/value pair database Usage:   del(key, db = NULL) Arguments: key:   name key (string raw vector) db:   database handle passed create transaction (see $begin method). Details:   helper method establishes temporary read-write transaction, calls corresponding method mdb_txn commits transaction.  possible use existing write transaction effect environment. Value:   scalar logical, indicating value deleted Note: lmdb.h mdb_del() exists Test key exists database. Usage:   exists(key, db = NULL) Arguments: key:   name key test (string raw vector).  Unlike get, put del (like mget, mput mdel), exists vectorised.  input can ; character vector length (returning length logical vector), raw vector (representing one key, returning scalar logical) list element either scalar character raw vector, returning logical length list. db:   database handle passed create transaction (see $begin method). Details:   extension raw LMDB API works using mdb_get key (lmdb need copy data) testing whether return value MDB_SUCCESS MDB_NOTFOUND. helper method establishes temporary read-transaction, calls corresponding method mdb_txn aborts transaction. Value:   logical vector list List keys database Usage:   list(starts_with = NULL, as_raw = FALSE, size = NULL, db = NULL) Arguments: starts_with:   Optionally, prefix strings.  Note regular expression filename glob.  Using foo match foo, foo:bar foobar fo FOO.  LMDB stores keys sorted tree, using prefix can greatly reduce number keys need tested. as_raw:   interpretation as_raw $get() different default.  expected time keys strings, default try return character vector as_raw = FALSE.  Change default database contains raw keys. size:   use starts_with, optionally guess number keys returned.  starts_with = NULL can look number keys directly ignored. db:   database handle passed create transaction (see $begin method). Details:   helper method establishes temporary read-transaction, calls corresponding method mdb_txn aborts transaction. mget Get values multiple keys (like $get vectorised key) Usage:   mget(key, as_raw = NULL, db = NULL) Arguments: key:   keys get values .  Zero, one keys allowed. as_raw:   $get(), logical (NULL) indicating raw string output expected desired. db:   database handle passed create transaction (see $begin method). Details:   helper method establishes temporary read-transaction, calls corresponding method mdb_txn aborts transaction. mput Put multiple values database (like $put vectorised key/value). Usage:   mput(key, value, overwrite = TRUE, append = FALSE, db = NULL) Arguments: key:   keys set value:   values set keys.  Must length key. overwrite:   $put append:   $put db:   database handle passed create transaction (see $begin method). Details:   implementation simply calls mdb_put repeatedly (single round error checking) duplicate key entries result last key winning. helper method establishes temporary read-write transaction, calls corresponding method mdb_txn commits transaction.  possible use existing write transaction effect environment. mdel Delete multiple values database (like $del vectorised key). Usage:   mdel(key, db = NULL) Arguments: key:   keys delete db:   database handle passed create transaction (see $begin method). Details:   helper method establishes temporary read-write transaction, calls corresponding method mdb_txn commits transaction.  possible use existing write transaction effect environment. Value:   logical vector, length key, indicating key deleted.","code":""},{"path":"https://richfitz.github.io/thor/reference/mdb_dbi.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Use mdb transactions — mdb_dbi","text":"","code":"# As always, start with the environment.  Because we're going to # use more than one database, we must set `maxdbs` to more than 1: env <- thor::mdb_env(tempfile(), maxdbs = 10)  # The default environment - every database db <- env$open_database() # The default database will always have id 1 and no name db$id() #> [1] 1 db$name() #> NULL  # A different database foo <- env$open_database(\"foo\") foo$id() #> [1] 2 foo$name() #> [1] \"foo\"  # Opening a database multiple times has no effect - it returns the # same data base every call. identical(env$open_database(\"foo\"), foo) # TRUE #> [1] TRUE  # Then we can put some data int the new database: txn <- env$begin(foo, write = TRUE) txn$put(\"hello\", \"world\") txn$commit()  # Now we have values in the \"foo\" database, but not the default one: env$get(\"hello\", db = NULL, missing_is_error = FALSE) # NULL #> NULL env$get(\"hello\", db = foo,  missing_is_error = FALSE) # \"world\" #> [1] \"world\"  # Cleanup env$destroy()"},{"path":"https://richfitz.github.io/thor/reference/mdb_env.html","id":null,"dir":"Reference","previous_headings":"","what":"Create an mdb_env environment — mdb_env","title":"Create an mdb_env environment — mdb_env","text":"Create mdb_env \"environment\" object.  way interacts lmdb database created, includes methods querying environment, creating databases, starting transactions () adding, getting removing data.  page includes reference documentation object readers first directed vignette (vignette(\"thor\").","code":""},{"path":"https://richfitz.github.io/thor/reference/mdb_env.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create an mdb_env environment — mdb_env","text":"","code":"mdb_env(   path,   mode = as.octmode(\"644\"),   subdir = TRUE,   readonly = FALSE,   metasync = TRUE,   sync = TRUE,   writemap = FALSE,   lock = TRUE,   mapasync = FALSE,   rdahead = TRUE,   meminit = TRUE,   maxdbs = NULL,   maxreaders = NULL,   mapsize = NULL,   reversekey = FALSE,   create = TRUE )"},{"path":"https://richfitz.github.io/thor/reference/mdb_env.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create an mdb_env environment — mdb_env","text":"path directory database files reside. create TRUE path created exist (contrast lmdb C API).  subdir FALSE path database file additional lock file created appending \"-lock\" path. mode file mode (UNIX file permissions) set created files.  must octmode object, default (.octmode(\"644\") user-writeable world-readable. subdir default, lmdb creates files within directory (path).  subdir = FALSE path interpreted path main database file lock file created \"-lock\" appended filename. Passing subdir = FALSE equivalent lmdb's MDB_NOSUBDIR flag. readonly Open environment read-mode.  write operations allowed.  LMDB still modify lock file. Passing readonly = TRUE equivalent lmdb's MDB_RDONLY flag.  want modify nothing disk, pass lock = FALSE also (beware concurrent access may go plan). metasync FALSE, flush system buffers disk per transaction, omit metadata flush. Defer system flushes files disk, next commit next call $sync() method.  optimization maintains database integrity, system crash may undo last committed transaction. .e. preserves , C (atomicity, consistency, isolation) properties D (durability) database property.  Passing metasync = FALSE equivalent lmdb's MDB_NOMETASYNC flag. sync FALSE, flush system buffers disk committing transaction.  optimization means system crash can corrupt database lose last transactions buffers yet flushed disk.  risk governed often system flushes dirty buffers disk often $sync() method called.  However, filesystem preserves write order writemap = FALSE, transactions exhibit ACI (atomicity, consistency, isolation) properties lose D (durability).  .e. database integrity maintained, system crash may undo final transactions. Note sync = FALSE, writemap = TRUE leaves system hint write transactions disk, unless $sync() called.  map_async = TRUE, writemap = TRUE may preferable.  Passing sync = FALSE equivalent lmdb's MDB_NOSYNC flag. writemap TRUE, use writeable memory map unless readonly = TRUE set. uses fewer mallocs loses protection application bugs like wild pointer writes bad updates database. may slightly faster databases fit entirely RAM, slower databases larger RAM. Incompatible nested transactions. mix processes writemap = TRUE writemap = FALSE environment.  can defeat durability ($sync() etc).  Passing writemap = TRUE equivalent lmdb's MDB_WRITEMAP flag. lock FALSE, locking. concurrent access anticipated, caller must manage concurrency . proper operation caller must enforce single-writer semantics, must ensure readers using old transactions writer active. simplest approach use exclusive lock readers may active writer begins.  Passing lock = FALSE equivalent lmdb's MDB_NOLOCK flag. mapasync TRUE, using writemap = TRUE, use asynchronous flushes disk.  sync = FALSE, system crash can corrupt database lose last transactions. Calling $sync() ensures -disk database integrity next commit.  Passing mapasync = FALSE equivalent lmdb's MDB_MAPASYNC flag. rdahead FALSE, turn readahead. operating systems perform readahead read requests default. option turns OS supports . Turning may help random read performance DB larger RAM system RAM full.  rdahead = FALSE implemented Windows.  Passing rdahead = FALSE equivalent lmdb's MDB_NORDAHEAD flag. meminit FALSE, initialize malloc'd memory writing unused spaces data file. default, memory pages written data file obtained using malloc. pages may reused subsequent transactions, freshly malloc'd pages initialized zeroes use. avoids persisting leftover data code (used heap subsequently freed memory) data file. Note many system libraries may allocate free memory heap arbitrary uses. E.g., stdio may use heap file /O buffers. initialization step modest performance cost applications may want disable using flag. option can problem applications handle sensitive data like passwords, makes memory checkers like Valgrind noisy. flag needed writemap = TRUE, writes directly mmap instead using malloc pages.  Passing meminit = FALSE equivalent lmdb's MDB_NOMEMINIT. maxdbs number databases available within environment.  0 (default), environment holds just one database (main db).  use named databases must set greater one. maxreaders Maximum number simultaneous read transactions.  Can set first process open environment. mapsize Maximum size database may grow ; used size memory mapping. measured bytes, default (set lmdb) 1MB (2^20 bytes). database grows larger map_size, error thrown user must close reopen mdb_env.  64-bit penalty making huge (say 1TB). Must <2GB 32-bit. Increasing may cause operating system report disk used database open, though just amount reserved. reversekey Passed open_database main database.  TRUE, keys strings compared reverse order, end strings beginning (e.g., DNS names). default, keys treated strings compared beginning end.  Passing reversekey = TRUE equivalent lmdb's MDB_REVERSEKEY. create FALSE, create directory path missing.","code":""},{"path":"https://richfitz.github.io/thor/reference/mdb_env.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create an mdb_env environment — mdb_env","text":"thor package wrapper around lmdb provided pointers relevant options lmdb - wrapper fairly thin picks limitations restrictions underlying library.  portions documentation derives lmdb source documentation - file lmdb.h particular.","code":""},{"path":"https://richfitz.github.io/thor/reference/mdb_env.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"Create an mdb_env environment — mdb_env","text":"path Return absolute path LMDB store (disk) Usage:   path() Value:   string Note: lmdb.h mdb_env_get_path() flags Return flags used construction LMDB environment Usage:   flags() Value:   named logical vector.  Names correspond arguments constructor. Note: lmdb.h mdb_env_get_flags() info Brief information LMDB environment Usage:   info() Value:   integer vector elements mapsize, last_pgno, last_txnid, maxreaders numreaders. Note: lmdb.h mdb_env_info() stat Brief statistics LMDB environment. Usage:   stat() Value:   integer vector elements psize (size database page), depth (depth B-tree), brancb_pages (number internal non-leaf) pages), leaf_pages (number leaf pages), overflow_pages (number overflow pages) entries (number data items). Note: lmdb.h mdb_env_stat() maxkeysize maximum size key (value can bigger ) Usage:   maxkeysize() Value:   single integer Note: lmdb.h mdb_env_get_maxkeysize() maxreaders maximum number readers Usage:   maxreaders() Value:   single integer Note: lmdb.h mdb_env_get_maxreaders() begin Begin transaction Usage:   begin(db = NULL, write = FALSE, sync = NULL, metasync = NULL) Arguments: db:   database handle, returned open_database.  NULL (default) default database used. write:   Scalar logical, indicating write transaction.  can one write transaction per database (see mdb_txn details) - error try open one. sync:   Scalar logical, indicating data synchronised synchronised (flushed disk) writes; see main parameter list. metasync:   Scalar logical, indicating metadata synchronised (flushed disk) writes; see main parameter list. Details:   Transactions key objects interacting LMDB database (aside convenience interface ).  described detail mdb_txn. Value:   mdb_txn object Note: lmdb.h mdb_begin() with_transaction Evaluate code within transaction Usage:   with_transaction(fun, db = NULL, write = FALSE) Arguments: fun:   function one argument work transaction.  with_transaction pass transaction function.  easily explained example, see bottom help db:   database handle, returned open_database.  NULL (default) default database used. write:   Scalar logical, indicating write transaction.  can one write transaction per database (see mdb_txn details) - error try open one. Details:   exists simplify pattern one wants open transaction, evaluate code transaction anything goes wrong abort, otherwise commit.  useful read-write transactions, can used (default readonly transactions, like begin(). open_database Open named database, return one already opened. Usage:   open_database(key = NULL, reversekey = FALSE, create = TRUE) Arguments: key:   Name database; NULL returns default database (always open). reversekey:   Compare strings reverse order? See reversekey documentation create:   Create database exist already? Details:   LMDB environments can hold multiple databases, provided opened maxdbs greater one.  always \"default\" database - unnamed dropped. databases key (.e., name) can dropped. database objects passed methods, notably drop_database begin Note: lmdb.h mdb_open() drop_database Drop database Usage:   drop_database(db, delete = TRUE) Arguments: db:   database object, returned open_database delete:   Scalar logical, indicating database deleted .  FALSE, values deleted database (.e., emptied). TRUE actual database deleted . Value:   return value, called side effects Note: lmdb.h mdb_drop() sync Flush data buffers disk. Usage:   sync(force = FALSE) Arguments: force:   Scalar logical; force synchronous flush.  Otherwise environment constructed sync = FALSE flushes omitted, mapasync = TRUE asynchronous. Details:   Data always written disk transaction committed, operating system may keep buffered.  LMDB always flushes OS buffers upon commit well, unless environment opened sync = FALSE part metasync = FALSE.  call valid environment opened readonly = TRUE. Note: lmdb.h mdb_env_sync() copy Copy entire environment state new path.  can used make backup database. Usage:   copy(path, compact = FALSE) Arguments: path:   Scalar character; new path compact:   Scalar logical; perform compaction copying?  omits free pages sequentially renumbers pages output.  can take longer default produce smaller database Value:   Invisibly, new path (allowing use $copy(tempfile)) Note: lmdb.h mdb_env_copy() & mdb_env_copy2() close Close environment.  closes cursors transactions (active write transactions aborted). Usage:   close() Value:   return value, called side effects Note: lmdb.h mdb_env_close() destroy Totally destroy LMDB environment.  closes database removes files.  Use care! Usage:   destroy() Value:   return value, called side effects reader_list List information database readers Usage:   reader_list() Value:   character matrix columns pid (process ID), thread (pointer address), txnid (small integer) Note: lmdb.h mdb_reader_list() reader_check Check , remove, stale entries reader lock table. Usage:   reader_check() Value:   integer, number stale readers discarded.  However, function primarily called side effect. Note: lmdb.h mdb_reader_check() get Retrieve value database Usage:   get(key, missing_is_error = TRUE, as_raw = NULL, db = NULL) Arguments: key:   string (raw vector) - key get missing_is_error:   Logical, indicating missing value error (default ).  Alternatively, missing_is_error = FALSE, missing value return NULL.  value can NULL (values must nonzero length) NULL unambiguously missing. as_raw:   Either NULL, logical, indicate result type required.  as_raw = NULL, default, value returned string possible.  possible return raw vector.  as_raw = TRUE, get() always return raw vector, even possibly represent value string.  as_raw = FALSE, get return string, throw error possible.  discussed detail thor vignette (vignette(\"thor\")) db:   database handle passed create transaction (see $begin method). Details:   helper method establishes temporary read-transaction, calls corresponding method mdb_txn aborts transaction. Note: lmdb.h mdb_get() put Put values database.  systems, might called \"set\". Usage:   put(key, value, overwrite = TRUE, append = FALSE, db = NULL) Arguments: key:   name key (string raw vector) value:   value save (string raw vector) overwrite:   Logical - TRUE overwrite existing data; FALSE throw error append:   Logical - TRUE, append given key/value end database.  option allows fast bulk loading keys already known correct order.  load unsorted keys append = TRUE error thrown db:   database handle passed create transaction (see $begin method). Details:   helper method establishes temporary read-write transaction, calls corresponding method mdb_txn commits transaction.  possible use existing write transaction effect environment. Note: lmdb.h mdb_put() del Remove key/value pair database Usage:   del(key, db = NULL) Arguments: key:   name key (string raw vector) db:   database handle passed create transaction (see $begin method). Details:   helper method establishes temporary read-write transaction, calls corresponding method mdb_txn commits transaction.  possible use existing write transaction effect environment. Value:   scalar logical, indicating value deleted Note: lmdb.h mdb_del() exists Test key exists database. Usage:   exists(key, db = NULL) Arguments: key:   name key test (string raw vector).  Unlike get, put del (like mget, mput mdel), exists vectorised.  input can ; character vector length (returning length logical vector), raw vector (representing one key, returning scalar logical) list element either scalar character raw vector, returning logical length list. db:   database handle passed create transaction (see $begin method). Details:   extension raw LMDB API works using mdb_get key (lmdb need copy data) testing whether return value MDB_SUCCESS MDB_NOTFOUND. helper method establishes temporary read-transaction, calls corresponding method mdb_txn aborts transaction. Value:   logical vector list List keys database Usage:   list(starts_with = NULL, as_raw = FALSE, size = NULL, db = NULL) Arguments: starts_with:   Optionally, prefix strings.  Note regular expression filename glob.  Using foo match foo, foo:bar foobar fo FOO.  LMDB stores keys sorted tree, using prefix can greatly reduce number keys need tested. as_raw:   interpretation as_raw $get() different default.  expected time keys strings, default try return character vector as_raw = FALSE.  Change default database contains raw keys. size:   use starts_with, optionally guess number keys returned.  starts_with = NULL can look number keys directly ignored. db:   database handle passed create transaction (see $begin method). Details:   helper method establishes temporary read-transaction, calls corresponding method mdb_txn aborts transaction. mget Get values multiple keys (like $get vectorised key) Usage:   mget(key, as_raw = NULL, db = NULL) Arguments: key:   keys get values .  Zero, one keys allowed. as_raw:   $get(), logical (NULL) indicating raw string output expected desired. db:   database handle passed create transaction (see $begin method). Details:   helper method establishes temporary read-transaction, calls corresponding method mdb_txn aborts transaction. mput Put multiple values database (like $put vectorised key/value). Usage:   mput(key, value, overwrite = TRUE, append = FALSE, db = NULL) Arguments: key:   keys set value:   values set keys.  Must length key. overwrite:   $put append:   $put db:   database handle passed create transaction (see $begin method). Details:   implementation simply calls mdb_put repeatedly (single round error checking) duplicate key entries result last key winning. helper method establishes temporary read-write transaction, calls corresponding method mdb_txn commits transaction.  possible use existing write transaction effect environment. mdel Delete multiple values database (like $del vectorised key). Usage:   mdel(key, db = NULL) Arguments: key:   keys delete db:   database handle passed create transaction (see $begin method). Details:   helper method establishes temporary read-write transaction, calls corresponding method mdb_txn commits transaction.  possible use existing write transaction effect environment. Value:   logical vector, length key, indicating key deleted.","code":""},{"path":"https://richfitz.github.io/thor/reference/mdb_env.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create an mdb_env environment — mdb_env","text":"","code":"# Create a new environment (just using defaults) env <- thor::mdb_env(tempfile())  # At its most simple (using temporary transactions) env$put(\"a\", \"hello world\") #> NULL env$get(\"a\") #> [1] \"hello world\"  # Or create transactions txn <- env$begin(write = TRUE) txn$put(\"b\", \"another\") txn$put(\"c\", \"value\")  # Transaction not committed so value not visible outside our transaction env$get(\"b\", missing_is_error = FALSE) #> NULL  # After committing, the values are visible for new transactions txn$commit() env$get(\"b\", missing_is_error = FALSE) #> [1] \"another\"  # A convenience method, 'with_transaction' exists to allow # transactional workflows with less code repetition.  # This will get the old value of a key 'a', set 'a' to a new value # and return the old value: env$with_transaction(function(txn) {   val <- txn$get(\"a\")   txn$put(\"a\", \"new_value\")   val }, write = TRUE) #> [1] \"hello world\"  # If an error occurred, the transaction would be aborted.  So far, # not very interesting!  # More interesting: implementing redis's RPOPLPUSH that takes the # last value off of the end of one list and pushes it into the # start of another. rpoplpush <- function(env, src, dest) {   f <- function(txn) {     # Take the value out of the source list and update     val <- unserialize(txn$get(src, as_raw = TRUE))     take <- val[[length(val)]]     txn$put(src, serialize(val[-length(val)], NULL))      # Put the value onto the destination list     val <- unserialize(txn$get(dest, as_raw = TRUE))     txn$put(dest, serialize(c(val, take), NULL))      # And we'll return the value that was modified     take   }   env$with_transaction(f, write = TRUE) }  # Set things up - a source list with numbers 1:5 and an empty # destination list env$put(\"src\", serialize(1:5, NULL)) #> NULL env$put(\"dest\", serialize(integer(0), NULL)) #> NULL  # then try it out: rpoplpush(env, \"src\", \"dest\") # 5 #> [1] 5 rpoplpush(env, \"src\", \"dest\") # 4 #> [1] 4 rpoplpush(env, \"src\", \"dest\") # 3 #> [1] 3  # Here is the state of the two lists unserialize(env$get(\"src\")) #> [1] 1 2 unserialize(env$get(\"dest\")) #> [1] 5 4 3  # The above code will fail if one of the lists is available env$del(\"dest\") #> [1] TRUE try(rpoplpush(env, \"src\", \"dest\")) #> Error in mdb_get(self$.ptr, self$.db$.ptr, key, missing_is_error, as_proxy,  :  #>   Key 'dest' not found in database  # but because it's in a transaction, this failed attempt leaves src # unchanged unserialize(env$get(\"src\")) #> [1] 1 2"},{"path":"https://richfitz.github.io/thor/reference/mdb_proxy.html","id":null,"dir":"Reference","previous_headings":"","what":"Proxy values — mdb_proxy","title":"Proxy values — mdb_proxy","text":"Proxy object.  exist try exploit LMDB's copy-free design.  LMDB can pass back read-pointer memory without copying .  rather immediately trying read whole thing , class provides \"proxy\" data.  moment terribly useful - can get length, peek first bytes!  used internally package support cursors.","code":""},{"path":"https://richfitz.github.io/thor/reference/mdb_proxy.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"Proxy values — mdb_proxy","text":"data Return value proxy object Usage:   data(as_raw = NULL) Arguments: as_raw:   Return value raw vector?  semantics mdb_env$get - NULL value returned string possible, otherwise raw vector.  TRUE value always returned raw vector, FALSE value always returned string (error thrown possible). Value:   string raw vector head Read first n bytes proxy Usage:   head(n = 6L, as_raw = NULL) Arguments: n:   number bytes read.  n greater length object whole object returned (behaviour head as_raw:   $data() is_raw Return whether know value raw .  affected whether successfully turned value string (case can return FALSE) NULL bytes detected.  latter condition may satisfied reading first bit proxy $head() Usage:   is_raw() Value:   logical can, otherwise NULL (symmetry as_raw) is_valid Test proxy object still valid.  proxy invalid, read .  Proxies invalidated parent transaction closed, write operations (e.g., put, del) occurred. Usage:   is_valid() Value:   Scalar logical size size data - number characters string, number bytes raw vector. Usage:   size() Value:   Scalar integer","code":""},{"path":"https://richfitz.github.io/thor/reference/mdb_proxy.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Proxy values — mdb_proxy","text":"","code":"# Start with a write transaction that has written a little data: env <- thor::mdb_env(tempfile()) txn <- env$begin(write = TRUE) txn$put(\"a\", \"apple\") txn$put(\"b\", \"banana\")  # We can get a proxy object back by passing as_proxy = TRUE p <- txn$get(\"a\", as_proxy = TRUE) p #> <mdb_val_proxy> #>   Public: #>     data(as_raw = NULL) #>     head(n = 6L, as_raw = NULL) #>     is_raw() #>     is_valid() #>     size()  # Without copying anything we can get the length of the data p$size() # == nchar(\"apple\") #> [1] 5  # And of course we can get the data p$data() #> [1] \"apple\" p$data(as_raw = TRUE) #> [1] 61 70 70 6c 65  # Referencing an invalid proxy is an error, but you can use # \"is_valid()\" check to see if it is valid p$is_valid() #> [1] TRUE  txn$put(\"c\", \"cabbage\") p$is_valid() #> [1] FALSE try(p$data()) #> Error in assert_valid() :  #>   mdb_val_proxy is invalid: transaction has modified database  # It is possible to read the first few bytes; this might be useful # to determine if (say) a value is a serialised R object: txn$put(\"d\", serialize(mtcars, NULL))  # The first 6 bytes of a binary serialised rds object is always # #   0x58 0x0a 0x00 0x00 0x00 0x02 # # for XDR serialisation, or # #   0x42 0x0a 0x02 0x00 0x00 0x00 # # for native little-endian serialisation. # # So with a little helper function is_rds <- function(x) {   h_xdr <- as.raw(c(0x58, 0x0a, 0x00, 0x00, 0x00, 0x02))   h_bin <- as.raw(c(0x42, 0x0a, 0x02, 0x00, 0x00, 0x00))   x6 <- head(x, 6L)   identical(x6, h_xdr) || identical(x6, h_bin) }  # We can see that the value stored at 'a' is not rds p1 <- txn$get(\"a\", as_proxy = TRUE) is_rds(p1$head(6, as_raw = TRUE)) #> [1] FALSE  # But the value stored at 'd' is: p2 <- txn$get(\"d\", as_proxy = TRUE) is_rds(p2$head(6, as_raw = TRUE)) #> [1] FALSE  # Retrieve and unserialise the value: head(unserialize(p2$data())) #>                    mpg cyl disp  hp drat    wt  qsec vs am gear carb #> Mazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1    4    4 #> Mazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1    4    4 #> Datsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1    4    1 #> Hornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0    3    1 #> Hornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2 #> Valiant           18.1   6  225 105 2.76 3.460 20.22  1  0    3    1"},{"path":"https://richfitz.github.io/thor/reference/mdb_txn.html","id":null,"dir":"Reference","previous_headings":"","what":"Use mdb transactions — mdb_txn","title":"Use mdb transactions — mdb_txn","text":"Transactions required every mdb operation.  Even using convenience functions mdb_env (get, etc), transaction created committed time.  Within transaction, either everything happens nothing happens, everything gets single consistent view database.","code":""},{"path":"https://richfitz.github.io/thor/reference/mdb_txn.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Use mdb transactions — mdb_txn","text":"can many read transactions per environment, one write transactions.  R single-threaded, means can simultaneously write mdb environment single object - attempts open write transactions block forever waiting lock released one thread!","code":""},{"path":"https://richfitz.github.io/thor/reference/mdb_txn.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"Use mdb transactions — mdb_txn","text":"id Return mdb internal id transaction Usage:   id() Value:   integer Note: lmdb.h mdb_txn_id() stat Brief statistics database.  mdb_env's stat() applying transaction Usage:   stat() Value:   integer vector elements psize (size database page), depth (depth B-tree), brancb_pages (number internal non-leaf) pages), leaf_pages (number leaf pages), overflow_pages (number overflow pages) entries (number data items). Note: lmdb.h mdb_stat() commit Commit changes made transaction database, invalidate transaction, cursors belonging (.e., committed transaction used ) Usage:   commit() Value:   Nothing, called side effects Note: lmdb.h mdb_txn_commit() abort Abandon changes made transaction database, invalidate transaction, cursors belonging (.e., aborted transaction used ).  read-transactions practical difference abort commit, except using abort allows transaction recycled efficiently. Usage:   abort(cache = TRUE) Arguments: cache:   Logical, indicating read-transaction cached recycling Value:   Nothing, called side effects Note: lmdb.h mdb_txn_abort() cursor Create mdb_cursor object transaction. can used powerful database interactions. Usage:   cursor() Value:   mdb_cursor object. Note: lmdb.h mdb_cursor_open() get Retrieve value database Usage:   get(key, missing_is_error = TRUE, as_proxy = FALSE, as_raw = NULL) Arguments: key:   string (raw vector) - key get missing_is_error:   Logical, indicating missing value error (default ).  Alternatively, missing_is_error = FALSE, missing value return NULL.  value can NULL (values must nonzero length) NULL unambiguously missing. as_proxy:   Return \"proxy\" object, defers copy R.  See mdb_proxy information. as_raw:   Either NULL, logical, indicate result type required.  as_raw = NULL, default, value returned string possible.  possible return raw vector.  as_raw = TRUE, get() always return raw vector, even possibly represent value string.  as_raw = FALSE, get return string, throw error possible.  discussed detail thor vignette (vignette(\"thor\")) Note: lmdb.h mdb_get() put Put values database.  systems, might called \"set\". Usage:   put(key, value, overwrite = TRUE, append = FALSE) Arguments: key:   name key (string raw vector) value:   value save (string raw vector) overwrite:   Logical - TRUE overwrite existing data; FALSE throw error append:   Logical - TRUE, append given key/value end database.  option allows fast bulk loading keys already known correct order.  load unsorted keys append = TRUE error thrown Note: lmdb.h mdb_put() del Remove key/value pair database Usage:   del(key) Arguments: key:   name key (string raw vector) Value:   scalar logical, indicating value deleted Note: lmdb.h mdb_del() exists Test key exists database. Usage:   exists(key) Arguments: key:   name key test (string raw vector).  Unlike get, put del (like mget, mput mdel), exists vectorised.  input can ; character vector length (returning length logical vector), raw vector (representing one key, returning scalar logical) list element either scalar character raw vector, returning logical length list. Details:   extension raw LMDB API works using mdb_get key (lmdb need copy data) testing whether return value MDB_SUCCESS MDB_NOTFOUND. Value:   logical vector list List keys database Usage:   list(starts_with = NULL, as_raw = FALSE, size = NULL) Arguments: starts_with:   Optionally, prefix strings.  Note regular expression filename glob.  Using foo match foo, foo:bar foobar fo FOO.  LMDB stores keys sorted tree, using prefix can greatly reduce number keys need tested. as_raw:   interpretation as_raw $get() different default.  expected time keys strings, default try return character vector as_raw = FALSE.  Change default database contains raw keys. size:   use starts_with, optionally guess number keys returned.  starts_with = NULL can look number keys directly ignored. mget Get values multiple keys (like $get vectorised key) Usage:   mget(key, as_proxy = FALSE, as_raw = NULL) Arguments: key:   keys get values .  Zero, one keys allowed. as_proxy:   Logical, indicating list mdb_proxy objects returned. as_raw:   $get(), logical (NULL) indicating raw string output expected desired. mput Put multiple values database (like $put vectorised key/value). Usage:   mput(key, value, overwrite = TRUE, append = FALSE) Arguments: key:   keys set value:   values set keys.  Must length key. overwrite:   $put append:   $put Details:   implementation simply calls mdb_put repeatedly (single round error checking) duplicate key entries result last key winning. mdel Delete multiple values database (like $del vectorised key). Usage:   mdel(key) Arguments: key:   keys delete Value:   logical vector, length key, indicating key deleted. replace Use temporary cursor replace item; function replace data held key return previous value (NULL exist).  See mdb_cursor fuller documentation. Usage:   replace(key, value, as_raw = NULL) Arguments: key:   key replace value:   new value value st key as_raw:   returned value, data returned? Value:   $get(), single data item either string raw vector. pop Use temporary cursor \"pop\" item; function delete item return value deletes . Usage:   pop(key, as_raw = NULL) Arguments: key:   key pop as_raw:   returned value, data returned? Value:   $get(), single data item either string raw vector. cmp Compare two keys ordering Usage:   cmp(, b) Arguments: :   key (string raw); need database b:   key compare b (string raw) Value:   scalar integer, -1 (< b), 0 (== b) 1 (> b). Note: lmdb.h mdb_cmp()","code":""},{"path":"https://richfitz.github.io/thor/reference/mdb_txn.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Use mdb transactions — mdb_txn","text":"","code":"# Start by creating a new environment, and within that a write # transaction env <- thor::mdb_env(tempfile()) txn <- env$begin(write = TRUE)  # With this transaction we can write values and see them as set txn$put(\"a\", \"hello\") txn$get(\"a\") #> [1] \"hello\"  # But because the transaction is not committed, any new # transaction will not see the values: env$get(\"a\", missing_is_error = FALSE) # NULL #> NULL txn2 <- env$begin() txn2$get(\"a\", missing_is_error = FALSE) # NULL #> NULL  # Once we commit a transaction, *new* transactions will see the # value txn$commit() env$get(\"a\") # \"hello\" #> [1] \"hello\" env$begin()$get(\"a\") # \"hello\" #> [1] \"hello\"  # But old transactions retain their consistent view of the database txn2$get(\"a\", missing_is_error = FALSE) #> NULL  # Cleanup env$destroy()"},{"path":"https://richfitz.github.io/thor/reference/storr_thor.html","id":null,"dir":"Reference","previous_headings":"","what":"Thor driver for storr — storr_thor","title":"Thor driver for storr — storr_thor","text":"Storr driver thor.  allows thor used storage backend storr package presents higher level content addressable key/value store suitable storing R objects.","code":""},{"path":"https://richfitz.github.io/thor/reference/storr_thor.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Thor driver for storr — storr_thor","text":"","code":"storr_thor(   env,   prefix = \"\",   hash_algorithm = NULL,   default_namespace = \"objects\" )  driver_thor(env, prefix = \"\", hash_algorithm = NULL)"},{"path":"https://richfitz.github.io/thor/reference/storr_thor.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Thor driver for storr — storr_thor","text":"env thor environment prefix optional prefix.  given, use : last character nice looking keys (e.g., storr: generate keys like storr:keys:namespace:name.  given assume storr user database destroy called delete entire database. hash_algorithm Optional hash algorithm use.  Defaults md5, whatever existing algorithm database opened.  mix algorithms. default_namespace default namespace store objects .  Defaults objects, storr drivers.","code":""}]
